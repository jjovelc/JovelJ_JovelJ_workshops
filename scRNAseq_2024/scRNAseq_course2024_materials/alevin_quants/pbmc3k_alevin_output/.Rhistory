# this would make downstream analysis extremely challenging.
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca")
obj <- FindClusters(obj, resolution = 2, cluster.name = "unintegrated_clusters")
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated")
# Visualize by batch and cell type annotation
# cell type annotation were previously added by Azimuth
DimPlot(obj, reduction = "umap.unintegrated",
group.by = "Method")
DimPlot(obj, reduction = "umap.unintegrated",
group.by = "predicted.celltype.l2")
# CCA integration
obj <- IntegrateLayers(
object = obj, method = CCAIntegration,
orig.reduction = "pca", new.reduction = "integrated.cca",
verbose = FALSE
)
# RPCA integration
obj <- IntegrateLayers(
object = obj, method = RPCAIntegration,
orig.reduction = "pca", new.reduction = "integrated.rpca",
verbose = FALSE
)
# Harmony integration
obj <- IntegrateLayers(
object = obj, method = HarmonyIntegration,
orig.reduction = "pca", new.reduction = "harmony",
verbose = FALSE
)
# FastMNN integration
obj <- IntegrateLayers(
object = obj, method = FastMNNIntegration,
new.reduction = "integrated.mnn",
verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- FindNeighbors(obj, reduction = "integrated.cca", dims = 1:30)
obj <- FindClusters(obj, resolution = 2, cluster.name = "cca_clusters")
obj <- RunUMAP(obj, reduction = "integrated.cca", dims = 1:30, reduction.name = "umap.cca")
p1 <- DimPlot(
obj,
reduction = "umap.cca",
group.by = c("Method", "predicted.celltype.l2", "cca_clusters"),
combine = FALSE, label.size = 2
)
p1
.rs.restartR()
shiny::runApp('jj/data_analysis/juanJovel/Rshiny/shiny_react.R')
runApp('jj/data_analysis/juanJovel/Rshiny/shiny_react.R')
install.packages("shiny.react")
library(shiny)
library(shiny.react)
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/kallisto_results/counts_unfiltered'
library(BUSpaRse)
library(TENxBUSData)
library(ggplot2)
library(magrittr)
library(data.table)
library(Seurat)
library(SeuratData)
library(DropletUtils)
library(Matrix)
library(Azimuth)
library(patchwork)
theme_set(theme_bw())
ifnb <- LoadData("ifnb")
read_count_output <- function(dir, name, tcc = FALSE) {
dir <- normalizePath(dir, mustWork = TRUE)
m <- readMM(paste0(dir, "/", name, ".mtx"))
m <- Matrix::t(m)
m <- as(m, "dgCMatrix")
# The matrix read has cells in rows
ge <- if (tcc) ".ec.txt" else ".genes.txt"
con_genes <- file(paste0(dir, "/", name, ge))
con_bcs <- file(paste0(dir, "/", name, ".barcodes.txt"))
genes <- readLines(con_genes)
barcodes <- readLines(con_bcs)
colnames(m) <- barcodes
rownames(m) <- genes
close(con_genes)
close(con_bcs)
return(m)
}
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/kallisto_results/counts_unfiltered'
res_mat <- read_count_output(dir,"cells_x_genes")
dim(res_mat)
tot_counts <- Matrix::colSums(res_mat)
summary(tot_counts)
tot_counts <- Matrix::colSums(res_mat)
summary(tot_counts)
# Compute barcode rank
bc_rank <- barcodeRanks(res_mat)
qplot(bc_rank$total, bc_rank$rank, geom = "line") +
geom_vline(xintercept = metadata(bc_rank)$knee, color = "blue", linetype = 2) +
geom_vline(xintercept = metadata(bc_rank)$inflection, color = "green", linetype = 2) +
annotate("text", y = 1000, x = 1.5 * c(metadata(bc_rank)$knee, metadata(bc_rank)$inflection),
label = c("knee", "inflection"), color = c("blue", "green")) +
scale_x_log10() +
scale_y_log10() +
labs(y = "Barcode rank", x = "Total UMI count")
# Filter the matrix
res_mat <- res_mat[, tot_counts > metadata(bc_rank)$inflection]
dim(res_mat)
# Create and preprocess the Seurat object
pbmc4k <- CreateSeuratObject(res_mat, min.cells = 3)
pbmc4k <- NormalizeData(pbmc4k, assay = "RNA", normalization.method = "LogNormalize", scale.factor = 10000)
pbmc4k <- ScaleData(pbmc4k, verbose = FALSE)
pbmc4k <- FindVariableFeatures(pbmc4k, verbose = FALSE)
# The RunAzimuth function can take a Seurat object as input
pbmc4k <- RunAzimuth(data.seurat,
reference = "pbmcref")
# The RunAzimuth function can take a Seurat object as input
pbmc4k <- RunAzimuth(pbmc4k,
reference = "pbmcref")
p1 <- DimPlot(data.seurat, group.by = "predicted.celltype.l2", label = TRUE, label.size = 3) + NoLegend()
p1 <- DimPlot(pbmc4k, group.by = "predicted.celltype.l2", label = TRUE, label.size = 3) + NoLegend()
p1
pbmc4k$predicted.celltype.l2
grepl("CD14 Mono", pbmc4k$predicted.celltype.l2)
grepl("CD16 Mono", pbmc4k$predicted.celltype.l2)
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/kallisto_results/counts_unfiltered/test'
res_mat <- read_count_output(dir,"cells_x_genes")
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/test'
res_mat <- read_count_output(dir,"cells_x_genes")
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/test'
res_mat <- read_count_output(dir,"cells_x_genes")
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/test'
res_mat <- read_count_output(dir,"cells_x_genes")
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/test'
res_mat <- read_count_output(dir,"cells_x_genes")
dim(res_mat)
tot_counts <- Matrix::colSums(res_mat)
summary(tot_counts)
# Compute barcode rank
bc_rank <- barcodeRanks(res_mat)
qplot(bc_rank$total, bc_rank$rank, geom = "line") +
geom_vline(xintercept = metadata(bc_rank)$knee, color = "blue", linetype = 2) +
geom_vline(xintercept = metadata(bc_rank)$inflection, color = "green", linetype = 2) +
annotate("text", y = 1000, x = 1.5 * c(metadata(bc_rank)$knee, metadata(bc_rank)$inflection),
label = c("knee", "inflection"), color = c("blue", "green")) +
scale_x_log10() +
scale_y_log10() +
labs(y = "Barcode rank", x = "Total UMI count")
# Filter the matrix
res_mat <- res_mat[, tot_counts > metadata(bc_rank)$inflection]
dim(res_mat)
# Create and preprocess the Seurat object
pbmc4k <- CreateSeuratObject(res_mat, min.cells = 3)
pbmc4k <- NormalizeData(pbmc4k, assay = "RNA", normalization.method = "LogNormalize", scale.factor = 10000)
pbmc4k <- ScaleData(pbmc4k, verbose = FALSE)
pbmc4k <- FindVariableFeatures(pbmc4k, verbose = FALSE)
# The RunAzimuth function can take a Seurat object as input
pbmc4k <- RunAzimuth(pbmc4k,
reference = "pbmcref")
p1 <- DimPlot(pbmc4k, group.by = "predicted.celltype.l2", label = TRUE, label.size = 3) + NoLegend()
p1
# Ensure that seurat_annotations is correctly assigned as a factor
pbmc4k$seurat_annotations <- factor(pbmc4k$predicted.celltype.l2)
# Set identities using the actual data from seurat_annotations
Idents(pbmc4k) <- pbmc4k$seurat_annotations
table(Idents(pbmc4k))
Idents(pbmc4k)
monocyte.de.markers <- FindMarkers(pbmc4k, ident.1 = "CD16 Mono",
ident.2 = "CD14 Mono")
pbmc4k <- NormalizeData(pbmc4k, assay = "RNA", normalization.method = "LogNormalize", scale.factor = 10000)
monocyte.de.markers <- FindMarkers(pbmc4k, ident.1 = "CD16 Mono",
ident.2 = "CD14 Mono")
# view results
head(monocyte.de.markers)
pbmc4k <- RunAzimuth(pbmc4k,
reference = "pbmcref")
p1 <- DimPlot(pbmc4k, group.by = "predicted.celltype.l2", label = TRUE, label.size = 3) + NoLegend()
p1
monocyte.de.markers.LR <- FindMarkers(ifnb, ident.1 = "CD14 Mono", ident.2 = "CD16 Mono", test.use = "LR")
ifnb <- LoadData("ifnb")
Idents(ifnb) <- "seurat_annotations"
ifnb$seurat_annotations
ifnb$stim
head(ifnb$stim)
tail(ifnb$stim)
# Since this dataset contains treatment information (control versus stimulated
# with interferon-beta), we can also ask what genes change in different
# conditions for cells of the same type. First, we create a column in the
# meta.data slot to hold both the cell type and treatment information and
# switch the current Idents to that column. Then we use FindMarkers() to find
# the genes that are different between control and stimulated CD14 monocytes.
ifnb$celltype.stim <- paste(ifnb$seurat_annotations, ifnb$stim, sep = "_")
ifnb$celltype.stim
Idents(ifnb) <- "celltype.stim"
ifnb$celltype.stim
mono.de <- FindMarkers(ifnb, ident.1 = "CD14 Mono_STIM",
ident.2 = "CD14 Mono_CTRL", verbose = FALSE)
head(mono.de, n = 10)
monocyte.de.markers.wilcox_limma <- FindMarkers(ifnb, ident.1 = "CD14 Mono", ident.2 = "CD16 Mono", test.use = "wilcox_limma")
# Next one requires installing package MAST
# BiocManager::install("MAST")
monocyte.de.markers.mast   <- FindMarkers(ifnb, ident.1 = "CD14 Mono", ident.2 = "CD16 Mono", test.use = "MAST")
# Next one requires installing package MAST
# BiocManager::install("MAST")
monocyte.de.markers.mast   <- FindMarkers(ifnb, ident.1 = "CD14 Mono_CTRL", ident.2 = "CD14 Mono_STIM", test.use = "MAST")
head(monocyte.de.markers.mast)
monocyte.de.markers.deseq2_pbmc4k <- FindMarkers(pbmc4k, ident.1 = "CD14 Mono", ident.2 = "CD16 Mono", test.use = "DESeq2")
head(monocyte.de.markers.deseq2_pbmc4k)
signRes <- subset(monocyte.de.markers.deseq2_pbmc4k, p_val_adj < 0.05)
signRes
nrow(signRes)
source("~/Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/basilHubbard/shunZhang/makeBarPlots.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/basilHubbard/shunZhang/makeBarPlots.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/basilHubbard/shunZhang/makeBarPlots.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/basilHubbard/shunZhang/makeBarPlots.R", echo=TRUE)
library(Signag)
devtools::install_version(package = 'Signac', version = package_version('0.2.5'))
install.packages("gggenes")
devtools::install_version(package = 'Signac', version = package_version('0.2.5'))
library(Signag)
devtools::install_github("stuart-lab/signac", ref = "develop")
devtools::install_github("stuart-lab/signac", ref = "develop")
devtools::install_github("stuart-lab/signac", ref = "develop")
pkgbuild::check_build_tools(debug = TRUE)
devtools::install_github("stuart-lab/signac", ref = "develop")
pkgbuild::check_build_tools(debug = TRUE)
pkgbuild::check_build_tools(debug = TRUE)
devtools::install_github("stuart-lab/signac", ref = "develop")
pkgbuild::check_build_tools(debug = TRUE)
pkgbuild::check_build_tools(debug = TRUE)
pkgbuild::check_build_tools(debug = TRUE)
pkgbuild::check_build_tools(debug = TRUE)
export CPPFLAGS="-I/opt/homebrew/opt/llvm/include"
pkgbuild::check_build_tools(debug = TRUE)
devtools::install_github("timoast/signac")
# https://satijalab.org/seurat/articles/seurat5_integration
library(Seurat)
library(SeuratData)
library(SeuratWrappers)
library(Azimuth)
options(future.globals.maxSize = 1e9)
library(Azimuth)
packageVersion("shiny")
shiny::runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1/app.R')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1')
library(bslib)
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1/example2')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1/example2')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1/example2')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1/example2')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/example3.R')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/example3.R')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/example3.R')
library(Seurat)
library(SeuratData)
library(ggplot2)
library(Azimuth)
library(patchwork)
InstallData("panc8")
panc8 <- LoadData("panc8")
panc8 <- RunAzimuth(panc8, reference = "pancreasref")
p1 <- DimPlot(panc8, group.by = "celltype", label = TRUE, label.size = 3) + NoLegend()
p1
library(SeuratWrappers)
library(monocle3)
BiocManager::install("monocle3")
library(monocle3)
BiocManager::install(c('BiocGenerics', 'DelayedArray', 'DelayedMatrixStats',
'limma', 'lme4', 'S4Vectors', 'SingleCellExperiment',
'SummarizedExperiment', 'batchelor', 'HDF5Array',
'terra', 'ggrastr'))
devtools::install_github('cole-trapnell-lab/monocle3')
pkgbuild::check_build_tools(debug = TRUE)
devtools::install_github('cole-trapnell-lab/monocle3')
install.packages("pkgbuild")
library(pkgbuild)
pkgbuild::check_build_tools(debug = TRUE)
devtools::install_github('cole-trapnell-lab/monocle3', ref="develop")
xcode-select --install
Sys.setenv(PATH = paste("/usr/bin", Sys.getenv("PATH"), sep = ":"))
Sys.setenv(CC = "/usr/bin/clang")
Sys.setenv(CXX = "/usr/bin/clang++")
system("which clang")
install.packages(‘grr’, ‘leidenbase’, ‘pbmcapply’, ‘rsample’, ‘slam’, ‘spdep’, ‘speedglm’)
install.packages("grr","leidenbase","pbmcapply","rsample","slam","spdep","speedglm")
install.packages("grr")
install.packages("leidenbase")
install.packages("pbmcapply")
install.packages("rsample")
install.packages("slam")
install.packages("spdep")
install.packages("speedglm")
install.packages("pkgbuild")
library(pkgbuild)
pkgbuild::check_build_tools(debug = TRUE)
Sys.setenv(PATH = paste("/usr/bin", Sys.getenv("PATH"), sep = ":"))
Sys.setenv(CC = "/usr/bin/clang")
Sys.setenv(CXX = "/usr/bin/clang++")
system("which clang")
# load required libraries
library(BiocGenerics)
library(DelayedArray)
library(monocle3)
library(SeuratWrappers)  # For Monocle3 and scVelo compatibility
# load required libraries
library(BiocGenerics)
library(DelayedArray)
library(monocle3)
library(SeuratWrappers)  # For Monocle3 and scVelo compatibility
library(monocle3)
library(Matrix)
setwd('/Users/juanjovel/OneDrive/jj/UofC/data_analysis/juanJovel/courses/2024/scRNAseq/final_version/alevin_quants')
pbmc3k <- readRDS('pbmc3k.rds')
# Convert the Seurat object to a Monocle 3 object for trajectory analysis.
# The monocle3 object is a CellDataSet (cds)
cds <- as.cell_data_set(pbmc3k)
# Preprocess the data for Monocle
cds <- preprocess_cds(cds, num_dim = 20)
BiocManager::install("slingshot")
library(slingshot)
# load required libraries
library(SeuratWrappers)  # For Monocle3 and scVelo compatibility
library(slingshot)
setwd('/Users/juanjovel/OneDrive/jj/UofC/data_analysis/juanJovel/courses/2024/scRNAseq/final_version/alevin_quants')
pbmc3k <- readRDS('pbmc3k.rds')
# Extract the reduced dimensions
reduced_dims <- Embeddings(pbmc3k, "umap")
# load required libraries
library(Seurat)  # For Monocle3 and scVelo compatibility
# Extract the reduced dimensions
reduced_dims <- Embeddings(pbmc3k, "umap")
# Run Slingshot
slingshot_obj <- slingshot(reduced_dims, clusterLabels = seurat_obj$seurat_clusters, start.clus = "0")
# Run Slingshot
slingshot_obj <- slingshot(reduced_dims, clusterLabels = pbmc3k$seurat_clusters, start.clus = "0")
# Plot the trajectories
plot(reduced_dims, col = seurat_obj$seurat_clusters, pch = 16, asp = 1)
# Plot the trajectories
plot(reduced_dims, col = pbmc3k$seurat_clusters, pch = 16, asp = 1)
lines(slingshot_obj, lwd = 2)
# Assuming you have a Seurat object named 'seurat_obj'
pbmc3k <- NormalizeData(pbmc3k)
pbmc3k <- FindVariableFeatures(pbmc3k)
pbmc3k <- ScaleData(pbmc3k)
pbmc3k <- RunPCA(pbmc3k)
pbmc3k <- FindNeighbors(pbmc3k, dims = 1:10)
pbmc3k <- FindClusters(pbmc3k, resolution = 0.5)
# Run UMAP for visualization
pbmc3k <- RunUMAP(pbmc3k, dims = 1:10)
# Extract the reduced dimensions
reduced_dims <- Embeddings(pbmc3k, "umap")
# Run Slingshot
slingshot_obj <- slingshot(reduced_dims, clusterLabels = pbmc3k$seurat_clusters, start.clus = "0")
# Plot the trajectories
plot(reduced_dims, col = pbmc3k$seurat_clusters, pch = 16, asp = 1)
lines(slingshot_obj, lwd = 2)
BiocManager::install("TSCAN")
#################################
library(TSCAN)
# Assuming you have a Seurat object named 'seurat_obj'
expr_matrix <- as.matrix(GetAssayData(pbmc3k, slot = "data"))
# Assuming you have a Seurat object named 'seurat_obj'
expr_matrix <- as.matrix(GetAssayData(pbmc3k, layer = "data"))
# Run TSCAN
tscan_result <- exprmclust(expr_matrix, nclust = 5)
# Run TSCAN
tscan_result <- exprmclust(expr_matrix)
install.packages("SCORPIUS"
)
#################################
library(SCORPIUS)
# Assuming you have a Seurat object named 'seurat_obj'
expr_matrix <- as.matrix(GetAssayData(pbmc3k, layer = "data"))
# Run SCORPIUS
scorp_result <- scorp(expr_matrix, ndim = 3)
# Run SCORPIUS
scorp_result <- scorpious(expr_matrix, ndim = 3)
BiocManager::install("destiny")
#################################
library(destiny)
# Assuming you have a Seurat object named 'seurat_obj'
expr_matrix <- as.matrix(GetAssayData(pbmc3k, layer = "data"))
# Create a DiffusionMap object
dm <- DiffusionMap(expr_matrix)
# Plot the diffusion map
plot(dm, main = "Diffusion Map")
# Extract pseudotime
pseudotime <- dm@eigenvectors[,1]
# Add pseudotime to Seurat object metadata
seurat_obj$pseudotime <- pseudotime
# Add pseudotime to Seurat object metadata
pbmc3k$pseudotime <- pseudotime
library(monocle3)
library(Matrix)
# Convert Seurat object to Monocle3 CellDataSet
cds <- as.cell_data_set(covid)
# Convert Seurat object to Monocle3 CellDataSet
cds <- as.cell_data_set(pbmc3k)
# Preprocess the data for Monocle
cds <- preprocess_cds(cds, num_dim = 20)
# Learn the trajectory
cds <- cluster_cells(cds)
cds <- learn_graph(cds)
plot_cells(cds, color_cells_by = "pseudotime")
# Assuming you have a Seurat object named 'seurat_obj'
pbmc3k <- NormalizeData(pbmc3k)
pbmc3k <- FindVariableFeatures(pbmc3k)
pbmc3k <- ScaleData(pbmc3k)
pbmc3k <- RunPCA(pbmc3k)
pbmc3k <- FindNeighbors(pbmc3k, dims = 1:10)
pbmc3k <- FindClusters(pbmc3k, resolution = 0.5)
# Run UMAP for visualization
pbmc3k <- RunUMAP(pbmc3k, dims = 1:10)
# Extract the reduced dimensions
reduced_dims <- Embeddings(pbmc3k, "umap")
# Run Slingshot
slingshot_obj <- slingshot(reduced_dims, clusterLabels = pbmc3k$seurat_clusters, start.clus = "0")
# Plot the trajectories
plot(reduced_dims, col = pbmc3k$seurat_clusters, pch = 16, asp = 1)
lines(slingshot_obj, lwd = 2)
packageVersion("slingshot")
reduced_dims <- Embeddings(pbmc3k, 'pca')[, 1:2]
pbmc3k@reductions$pca
reduced_dims
str(reduced_dims)
table(pbmc3k$seurat_clusters)
class(slingshot_obj)
slingshot_obj
# Plot the trajectories
# Plot with Slingshot's plot function
plot(slingshot_obj, col = pbmc3k$seurat_clusters, pch = 16, asp = 1)
plot(reduced_dims, col = pbmc3k$seurat_clusters, pch = 16, asp = 1)
# Plot the trajectories
# Plot with Slingshot's plot function
plot(slingshot_obj, col = pbmc3k$seurat_clusters, pch = 16, asp = 1)
lines(slingshot_obj, lwd = 2)
plot(reduced_dims, col = pbmc3k$seurat_clusters, pch = 16, asp = 1)
plot(reduced_dims, col = pbmc3k$seurat_clusters, pch = 16, asp = 1)
slingshot_obj
# Plot the trajectories
# Plot with Slingshot's plot function
plot(slingshot_obj, col = pbmc3k$seurat_clusters, pch = 16, asp = 1)
# Extract lineages from Slingshot object
lineages <- slingshot_obj@curves
slingshot_obj@metadata$lineages
# Extract lineages from Slingshot object
lineages <- slingshot_obj@metadata$lineages
# Create a data frame for lineages
lineage_df <- do.call(rbind, lapply(lineages, function(curve) {
data.frame(PC1 = curve$s[curve$ord, 1],
PC2 = curve$s[curve$ord, 2],
lineage = curve$lineage)
}))
# Convert reduced_dims to a data frame
reduced_df <- as.data.frame(reduced_dims)
reduced_df$cluster <- as.factor(pbmc3k$seurat_clusters)
# Plot
ggplot(reduced_df, aes(x = PC1, y = PC2, color = cluster)) +
geom_point(size = 1) +
geom_path(data = lineage_df, aes(x = PC1, y = PC2, group = lineage), color = "black", size = 1.5) +
theme_minimal() +
labs(title = "Slingshot Trajectories", x = "PC1", y = "PC2")
library(tidyverse)
# Plot
ggplot(reduced_df, aes(x = PC1, y = PC2, color = cluster)) +
geom_point(size = 1) +
geom_path(data = lineage_df, aes(x = PC1, y = PC2, group = lineage), color = "black", size = 1.5) +
theme_minimal() +
labs(title = "Slingshot Trajectories", x = "PC1", y = "PC2")
# Extract lineages from Slingshot object
lineages <- slingshot_obj@metadata$lineages
# Create a data frame for lineages
lineage_df <- do.call(rbind, lapply(lineages, function(curve) {
data.frame(PC1 = curve$s[curve$ord, 1],
PC2 = curve$s[curve$ord, 2],
lineage = curve$lineage)
}))
# Extract lineages from Slingshot object
lineages <- slingshot_obj@metadata$lineages
# Create a data frame for lineages
lineage_df <- do.call(rbind, lapply(lineages, function(curve) {
data.frame(PC1 = curve$s[curve$ord, 1],
PC2 = curve$s[curve$ord, 2],
lineage = curve$lineage)
}))
package.version("Matrix")
packageVersion("slingshot")
source("~/Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/courses/2024/scRNAseq/final_version/scripts/01_alevinQC.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/courses/2024/scRNAseq/final_version/scripts/01_alevinQC.R", echo=TRUE)
# Set the working directory
working_dir <- '/Users/juanjovel/OneDrive/jj/UofC/data_analysis/juanJovel/courses/2024/scRNAseq/final_version/alevin_quants/pbmc3k_alevin_output'
setwd(working_dir)
# Get the current working directory
dir <- getwd()
# Generate the Alevin QC report
alevinQCReport(
baseDir = dir,
sampleId = "pbmc3k",
outputFile = "pbmc3k_alevinReport.html",
outputFormat = "html_document",
outputDir = dir,
forceOverwrite = TRUE
)
# Generate the Alevin QC report
alevinQCReport(
baseDir = dir,
sampleId = "pbmc3k",
outputFile = "pbmc3k_alevinReport.html",
outputFormat = "html_document",
outputDir = dir,
forceOverwrite = TRUE
)
