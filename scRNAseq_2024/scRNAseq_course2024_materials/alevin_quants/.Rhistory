object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi-env", verbose = FALSE
)
reticulate::py_last_error()
# scVI integration
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi-env", verbose = FALSE
)
reticulate::py_last_error()
# scVI integration
py_config()
py_run_string("import llvmlite; import numba")
py_run_string("import llvmlite; import numba")
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
source("~/jj/data_analysis/juanJovel/pipelines/singleCell/dataIntegration_wSeurat/dataIntegration.R", echo=TRUE)
source("~/jj/data_analysis/juanJovel/pipelines/singleCell/dataIntegration_wSeurat/dataIntegration.R", echo=TRUE)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
reticulate::py_last_error()
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
source("~/jj/data_analysis/juanJovel/pipelines/singleCell/dataIntegration_wSeurat/dataIntegration.R", echo=TRUE)
obj <- FindNeighbors(obj, reduction = "integrated.cca", dims = 1:30)
obj <- FindClusters(obj, resolution = 2, cluster.name = "cca_clusters")
obj <- FindClusters(obj, resolution = 2, cluster.name = "cca_clusters")
obj <- RunUMAP(obj, reduction = "integrated.cca", dims = 1:30, reduction.name = "umap.cca")
p1 <- DimPlot(
obj,
reduction = "umap.cca",
group.by = c("Method", "predicted.celltype.l2", "cca_clusters"),
combine = FALSE, label.size = 2
)
obj <- FindNeighbors(obj, reduction = "integrated.scvi", dims = 1:30)
obj <- FindClusters(obj, resolution = 2, cluster.name = "scvi_clusters")
obj <- RunUMAP(obj, reduction = "integrated.scvi", dims = 1:30, reduction.name = "umap.scvi")
p2 <- DimPlot(
obj,
reduction = "umap.scvi",
group.by = c("Method", "predicted.celltype.l2", "scvi_clusters"),
combine = FALSE, label.size = 2
)
wrap_plots(c(p1, p2), ncol = 2, byrow = F)
# compare the expression of biological markers based on
# different clustering solutions, or visualize one method’s
# clustering solution on different UMAP visualizations.
p1 <- VlnPlot(
obj,
features = "rna_CD8A", group.by = "unintegrated_clusters"
) + NoLegend() + ggtitle("CD8A - Unintegrated Clusters")
# compare the expression of biological markers based on
# different clustering solutions, or visualize one method’s
# clustering solution on different UMAP visualizations.
p1 <- VlnPlot(
obj,
features = "rna_CD8A", group.by = "unintegrated_clusters"
) + NoLegend() + ggtitle("CD8A - Unintegrated Clusters")
p2 <- VlnPlot(
obj, "rna_CD8A",
group.by = "cca_clusters"
) + NoLegend() + ggtitle("CD8A - CCA Clusters")
p3 <- VlnPlot(
obj, "rna_CD8A",
group.by = "scvi_clusters"
) + NoLegend() + ggtitle("CD8A - scVI Clusters")
p1 | p2 | p3
p1
p2
p3
# UMAP clustering
obj <- RunUMAP(obj, reduction = "integrated.rpca", dims = 1:30, reduction.name = "umap.rpca")
p4 <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("cca_clusters"))
p5 <- DimPlot(obj, reduction = "umap.rpca", group.by = c("cca_clusters"))
p6 <- DimPlot(obj, reduction = "umap.scvi", group.by = c("cca_clusters"))
p4
p5
p6
p5
p6
# Once integrative analysis is complete, you can rejoin the layers
obj <- JoinLayers(obj)
obj
# Lastly, users can also perform integration using sctransform-normalized data
options(future.globals.maxSize = 3e+09)
obj <- SCTransform(obj)
obj <- RunPCA(obj, npcs = 30, verbose = F)
obj <- IntegrateLayers(
object = obj,
method = RPCAIntegration,
normalization.method = "SCT",
verbose = F
)
obj <- FindNeighbors(obj, dims = 1:30, reduction = "integrated.dr")
? FindNeighbors
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca")
obj <- FindClusters(obj, resolution = 2)
obj <- RunUMAP(obj, dims = 1:30, reduction = "integrated.dr")
# obj <- RunUMAP(obj, dims = 1:30, reduction = "integrated.dr")
# that reduction method was not found by the interpreter
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca")
.rs.restartR()
library(Seurat)
# SeuratData includes the data to be used here
library(SeuratData)
library(SeuratWrappers)
library(Azimuth)
library(ggplot2)
library(patchwork)
library(reticulate)
options(future.globals.maxSize = 1e9)
# Load the PBMC systemic comparative analysis dataset
obj <- LoadData("pbmcsca")
# select only cells with at least 1000 features
obj <- subset(obj, nFeature_RNA > 1000)
# Classify cells
obj <- RunAzimuth(obj, reference = 'pbmcref')
obj
obj[["RNA"]] <- split(obj[["RNA"]], f = obj$Method)
obj
obj@meta.data$Method
obj <- NormalizeData(obj)
obj <- FindVariableFeatures(obj)
obj <- ScaleData(obj)
obj <- RunPCA(obj)
# Visualize a standard analysis without integration
# While a UMAP analysis is just a visualization of this, clustering
# this dataset would return predominantly batch-specific clusters.
# Especially if previous cell-type annotations were not available,
# this would make downstream analysis extremely challenging.
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca")
obj <- FindClusters(obj, resolution = 2, cluster.name = "unintegrated_clusters")
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated")
# Visualize by batch and cell type annotation
# cell type annotation were previously added by Azimuth
DimPlot(obj, reduction = "umap.unintegrated",
group.by = "Method")
DimPlot(obj, reduction = "umap.unintegrated",
group.by = "predicted.celltype.l2")
# CCA integration
obj <- IntegrateLayers(
object = obj, method = CCAIntegration,
orig.reduction = "pca", new.reduction = "integrated.cca",
verbose = FALSE
)
# RPCA integration
obj <- IntegrateLayers(
object = obj, method = RPCAIntegration,
orig.reduction = "pca", new.reduction = "integrated.rpca",
verbose = FALSE
)
# Harmony integration
obj <- IntegrateLayers(
object = obj, method = HarmonyIntegration,
orig.reduction = "pca", new.reduction = "harmony",
verbose = FALSE
)
# FastMNN integration
obj <- IntegrateLayers(
object = obj, method = FastMNNIntegration,
new.reduction = "integrated.mnn",
verbose = FALSE
)
obj <- IntegrateLayers(
object = obj, method = scVIIntegration,
new.reduction = "integrated.scvi",
conda_env = "~/miniforge3/envs/scvi", verbose = FALSE
)
obj <- FindNeighbors(obj, reduction = "integrated.cca", dims = 1:30)
obj <- FindClusters(obj, resolution = 2, cluster.name = "cca_clusters")
obj <- RunUMAP(obj, reduction = "integrated.cca", dims = 1:30, reduction.name = "umap.cca")
p1 <- DimPlot(
obj,
reduction = "umap.cca",
group.by = c("Method", "predicted.celltype.l2", "cca_clusters"),
combine = FALSE, label.size = 2
)
p1
.rs.restartR()
shiny::runApp('jj/data_analysis/juanJovel/Rshiny/shiny_react.R')
runApp('jj/data_analysis/juanJovel/Rshiny/shiny_react.R')
install.packages("shiny.react")
library(shiny)
library(shiny.react)
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/kallisto_results/counts_unfiltered'
library(BUSpaRse)
library(TENxBUSData)
library(ggplot2)
library(magrittr)
library(data.table)
library(Seurat)
library(SeuratData)
library(DropletUtils)
library(Matrix)
library(Azimuth)
library(patchwork)
theme_set(theme_bw())
ifnb <- LoadData("ifnb")
read_count_output <- function(dir, name, tcc = FALSE) {
dir <- normalizePath(dir, mustWork = TRUE)
m <- readMM(paste0(dir, "/", name, ".mtx"))
m <- Matrix::t(m)
m <- as(m, "dgCMatrix")
# The matrix read has cells in rows
ge <- if (tcc) ".ec.txt" else ".genes.txt"
con_genes <- file(paste0(dir, "/", name, ge))
con_bcs <- file(paste0(dir, "/", name, ".barcodes.txt"))
genes <- readLines(con_genes)
barcodes <- readLines(con_bcs)
colnames(m) <- barcodes
rownames(m) <- genes
close(con_genes)
close(con_bcs)
return(m)
}
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/kallisto_results/counts_unfiltered'
res_mat <- read_count_output(dir,"cells_x_genes")
dim(res_mat)
tot_counts <- Matrix::colSums(res_mat)
summary(tot_counts)
tot_counts <- Matrix::colSums(res_mat)
summary(tot_counts)
# Compute barcode rank
bc_rank <- barcodeRanks(res_mat)
qplot(bc_rank$total, bc_rank$rank, geom = "line") +
geom_vline(xintercept = metadata(bc_rank)$knee, color = "blue", linetype = 2) +
geom_vline(xintercept = metadata(bc_rank)$inflection, color = "green", linetype = 2) +
annotate("text", y = 1000, x = 1.5 * c(metadata(bc_rank)$knee, metadata(bc_rank)$inflection),
label = c("knee", "inflection"), color = c("blue", "green")) +
scale_x_log10() +
scale_y_log10() +
labs(y = "Barcode rank", x = "Total UMI count")
# Filter the matrix
res_mat <- res_mat[, tot_counts > metadata(bc_rank)$inflection]
dim(res_mat)
# Create and preprocess the Seurat object
pbmc4k <- CreateSeuratObject(res_mat, min.cells = 3)
pbmc4k <- NormalizeData(pbmc4k, assay = "RNA", normalization.method = "LogNormalize", scale.factor = 10000)
pbmc4k <- ScaleData(pbmc4k, verbose = FALSE)
pbmc4k <- FindVariableFeatures(pbmc4k, verbose = FALSE)
# The RunAzimuth function can take a Seurat object as input
pbmc4k <- RunAzimuth(data.seurat,
reference = "pbmcref")
# The RunAzimuth function can take a Seurat object as input
pbmc4k <- RunAzimuth(pbmc4k,
reference = "pbmcref")
p1 <- DimPlot(data.seurat, group.by = "predicted.celltype.l2", label = TRUE, label.size = 3) + NoLegend()
p1 <- DimPlot(pbmc4k, group.by = "predicted.celltype.l2", label = TRUE, label.size = 3) + NoLegend()
p1
pbmc4k$predicted.celltype.l2
grepl("CD14 Mono", pbmc4k$predicted.celltype.l2)
grepl("CD16 Mono", pbmc4k$predicted.celltype.l2)
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/kallisto_results/counts_unfiltered/test'
res_mat <- read_count_output(dir,"cells_x_genes")
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/test'
res_mat <- read_count_output(dir,"cells_x_genes")
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/test'
res_mat <- read_count_output(dir,"cells_x_genes")
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/test'
res_mat <- read_count_output(dir,"cells_x_genes")
dir <- '/Users/juanjovel/jj/dayhoff/pipelines/singleCells/kallisto_bus/kolby_pilot1_results/test'
res_mat <- read_count_output(dir,"cells_x_genes")
dim(res_mat)
tot_counts <- Matrix::colSums(res_mat)
summary(tot_counts)
# Compute barcode rank
bc_rank <- barcodeRanks(res_mat)
qplot(bc_rank$total, bc_rank$rank, geom = "line") +
geom_vline(xintercept = metadata(bc_rank)$knee, color = "blue", linetype = 2) +
geom_vline(xintercept = metadata(bc_rank)$inflection, color = "green", linetype = 2) +
annotate("text", y = 1000, x = 1.5 * c(metadata(bc_rank)$knee, metadata(bc_rank)$inflection),
label = c("knee", "inflection"), color = c("blue", "green")) +
scale_x_log10() +
scale_y_log10() +
labs(y = "Barcode rank", x = "Total UMI count")
# Filter the matrix
res_mat <- res_mat[, tot_counts > metadata(bc_rank)$inflection]
dim(res_mat)
# Create and preprocess the Seurat object
pbmc4k <- CreateSeuratObject(res_mat, min.cells = 3)
pbmc4k <- NormalizeData(pbmc4k, assay = "RNA", normalization.method = "LogNormalize", scale.factor = 10000)
pbmc4k <- ScaleData(pbmc4k, verbose = FALSE)
pbmc4k <- FindVariableFeatures(pbmc4k, verbose = FALSE)
# The RunAzimuth function can take a Seurat object as input
pbmc4k <- RunAzimuth(pbmc4k,
reference = "pbmcref")
p1 <- DimPlot(pbmc4k, group.by = "predicted.celltype.l2", label = TRUE, label.size = 3) + NoLegend()
p1
# Ensure that seurat_annotations is correctly assigned as a factor
pbmc4k$seurat_annotations <- factor(pbmc4k$predicted.celltype.l2)
# Set identities using the actual data from seurat_annotations
Idents(pbmc4k) <- pbmc4k$seurat_annotations
table(Idents(pbmc4k))
Idents(pbmc4k)
monocyte.de.markers <- FindMarkers(pbmc4k, ident.1 = "CD16 Mono",
ident.2 = "CD14 Mono")
pbmc4k <- NormalizeData(pbmc4k, assay = "RNA", normalization.method = "LogNormalize", scale.factor = 10000)
monocyte.de.markers <- FindMarkers(pbmc4k, ident.1 = "CD16 Mono",
ident.2 = "CD14 Mono")
# view results
head(monocyte.de.markers)
pbmc4k <- RunAzimuth(pbmc4k,
reference = "pbmcref")
p1 <- DimPlot(pbmc4k, group.by = "predicted.celltype.l2", label = TRUE, label.size = 3) + NoLegend()
p1
monocyte.de.markers.LR <- FindMarkers(ifnb, ident.1 = "CD14 Mono", ident.2 = "CD16 Mono", test.use = "LR")
ifnb <- LoadData("ifnb")
Idents(ifnb) <- "seurat_annotations"
ifnb$seurat_annotations
ifnb$stim
head(ifnb$stim)
tail(ifnb$stim)
# Since this dataset contains treatment information (control versus stimulated
# with interferon-beta), we can also ask what genes change in different
# conditions for cells of the same type. First, we create a column in the
# meta.data slot to hold both the cell type and treatment information and
# switch the current Idents to that column. Then we use FindMarkers() to find
# the genes that are different between control and stimulated CD14 monocytes.
ifnb$celltype.stim <- paste(ifnb$seurat_annotations, ifnb$stim, sep = "_")
ifnb$celltype.stim
Idents(ifnb) <- "celltype.stim"
ifnb$celltype.stim
mono.de <- FindMarkers(ifnb, ident.1 = "CD14 Mono_STIM",
ident.2 = "CD14 Mono_CTRL", verbose = FALSE)
head(mono.de, n = 10)
monocyte.de.markers.wilcox_limma <- FindMarkers(ifnb, ident.1 = "CD14 Mono", ident.2 = "CD16 Mono", test.use = "wilcox_limma")
# Next one requires installing package MAST
# BiocManager::install("MAST")
monocyte.de.markers.mast   <- FindMarkers(ifnb, ident.1 = "CD14 Mono", ident.2 = "CD16 Mono", test.use = "MAST")
# Next one requires installing package MAST
# BiocManager::install("MAST")
monocyte.de.markers.mast   <- FindMarkers(ifnb, ident.1 = "CD14 Mono_CTRL", ident.2 = "CD14 Mono_STIM", test.use = "MAST")
head(monocyte.de.markers.mast)
monocyte.de.markers.deseq2_pbmc4k <- FindMarkers(pbmc4k, ident.1 = "CD14 Mono", ident.2 = "CD16 Mono", test.use = "DESeq2")
head(monocyte.de.markers.deseq2_pbmc4k)
signRes <- subset(monocyte.de.markers.deseq2_pbmc4k, p_val_adj < 0.05)
signRes
nrow(signRes)
source("~/Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/basilHubbard/shunZhang/makeBarPlots.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/basilHubbard/shunZhang/makeBarPlots.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/basilHubbard/shunZhang/makeBarPlots.R", echo=TRUE)
source("~/Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/basilHubbard/shunZhang/makeBarPlots.R", echo=TRUE)
library(Signag)
devtools::install_version(package = 'Signac', version = package_version('0.2.5'))
install.packages("gggenes")
devtools::install_version(package = 'Signac', version = package_version('0.2.5'))
library(Signag)
devtools::install_github("stuart-lab/signac", ref = "develop")
devtools::install_github("stuart-lab/signac", ref = "develop")
devtools::install_github("stuart-lab/signac", ref = "develop")
pkgbuild::check_build_tools(debug = TRUE)
devtools::install_github("stuart-lab/signac", ref = "develop")
pkgbuild::check_build_tools(debug = TRUE)
pkgbuild::check_build_tools(debug = TRUE)
devtools::install_github("stuart-lab/signac", ref = "develop")
pkgbuild::check_build_tools(debug = TRUE)
pkgbuild::check_build_tools(debug = TRUE)
pkgbuild::check_build_tools(debug = TRUE)
pkgbuild::check_build_tools(debug = TRUE)
export CPPFLAGS="-I/opt/homebrew/opt/llvm/include"
pkgbuild::check_build_tools(debug = TRUE)
devtools::install_github("timoast/signac")
# https://satijalab.org/seurat/articles/seurat5_integration
library(Seurat)
library(SeuratData)
library(SeuratWrappers)
library(Azimuth)
options(future.globals.maxSize = 1e9)
library(Azimuth)
packageVersion("shiny")
shiny::runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1/app.R')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1')
library(bslib)
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1/example2')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1/example2')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1/example2')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/tutorials/shinyBook1/chapter1/example2')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/example3.R')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/example3.R')
runApp('Library/CloudStorage/OneDrive-UniversityofCalgary/jj/UofC/data_analysis/juanJovel/Rshiny/example3.R')
library(Seurat)
library(SeuratData)
library(ggplot2)
library(Azimuth)
library(patchwork)
InstallData("panc8")
panc8 <- LoadData("panc8")
panc8 <- RunAzimuth(panc8, reference = "pancreasref")
p1 <- DimPlot(panc8, group.by = "celltype", label = TRUE, label.size = 3) + NoLegend()
p1
library(SeuratWrappers)
library(monocle3)
BiocManager::install("monocle3")
library(monocle3)
BiocManager::install(c('BiocGenerics', 'DelayedArray', 'DelayedMatrixStats',
'limma', 'lme4', 'S4Vectors', 'SingleCellExperiment',
'SummarizedExperiment', 'batchelor', 'HDF5Array',
'terra', 'ggrastr'))
devtools::install_github('cole-trapnell-lab/monocle3')
pkgbuild::check_build_tools(debug = TRUE)
devtools::install_github('cole-trapnell-lab/monocle3')
install.packages("pkgbuild")
library(pkgbuild)
pkgbuild::check_build_tools(debug = TRUE)
devtools::install_github('cole-trapnell-lab/monocle3', ref="develop")
xcode-select --install
Sys.setenv(PATH = paste("/usr/bin", Sys.getenv("PATH"), sep = ":"))
Sys.setenv(CC = "/usr/bin/clang")
Sys.setenv(CXX = "/usr/bin/clang++")
system("which clang")
install.packages(‘grr’, ‘leidenbase’, ‘pbmcapply’, ‘rsample’, ‘slam’, ‘spdep’, ‘speedglm’)
install.packages("grr","leidenbase","pbmcapply","rsample","slam","spdep","speedglm")
install.packages("grr")
install.packages("leidenbase")
install.packages("pbmcapply")
install.packages("rsample")
install.packages("slam")
install.packages("spdep")
install.packages("speedglm")
install.packages("pkgbuild")
library(pkgbuild)
pkgbuild::check_build_tools(debug = TRUE)
Sys.setenv(PATH = paste("/usr/bin", Sys.getenv("PATH"), sep = ":"))
Sys.setenv(CC = "/usr/bin/clang")
Sys.setenv(CXX = "/usr/bin/clang++")
system("which clang")
# load required libraries
library(BiocGenerics)
library(DelayedArray)
library(monocle3)
library(SeuratWrappers)  # For Monocle3 and scVelo compatibility
library(monocle3)
library(Matrix)
setwd('/Users/juanjovel/OneDrive/jj/UofC/data_analysis/juanJovel/courses/2024/scRNAseq/final_version/alevin_quants')
pbmc3k <- readRDS('pbmc3k.rds')
install.packages("SeuratWrappers")
library(SeuratWrappers)  # For Monocle3 and scVelo compatibility
remotes::install_github("satijalab/seurat-wrappers")
remotes::install_github("satijalab/seurat-wrappers", force=TRUE)
# load required libraries
library(BiocGenerics)
library(DelayedArray)
library(monocle3)
library(SeuratWrappers)  # For Monocle3 and scVelo compatibility
